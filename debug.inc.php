<?php
/**
 * Debug include functions, Make it easier to debug your PHP code.
 *
 * This file contains a number of functions to make it easier to debug
 * your PHP scripts.
 *
 * @author Evan Wills <evan.wills@acu.edu.au>
 * @version 3.0 beta
 * @package Debug
 */

/**
 * The following IF statement allows debug.inc.php to be included any
 * number of times so files that have been independantly tested won't
 * throw errors.
 */
if(!function_exists('debug')): 

/**
 * debug() displays the file name and line number it is being called
 * from (relative to the original script) and the string value or
 * variable name and value of any number of supplied arguments.
 *
 * NOTE: only variables declared outside of functions are in the
 *       global scope so only those variable names are accessible.
 *       debug() will not be able to report the names of variables
 *       declared within functions (or classes I think).
 *
 * There are a number of reserved (case insensitive) strings which
 * cause debug() to output specific data.
 * These reserved strings are:
 *    'help':	   help information about the debug function
 *    'backtrace': the contents of an array generated by debug_backtrace()
 *    'server':    the contents of the $_SERVER global array
 *    'request':   the contents of the $_REQUEST global array 
 *    'get':       the contents of the $_GET global array
 *    'post':      the contents of the $_POST global array
 *    'env':       the contents of the $_ENV global array
 *    'files':     the contents of the $_FILES global array
 *    'session':   the contents of the $_SESSION global array
 *    'cookie':    the contents of the $_COOKIE global array
 *    'globals':   the contents of the $GLOBALS global array
 *                 (will also accept global)
 *    'force_die': cause the debug function to kill the script after a
 *                 given number of times (defined by max_times)
 *                 (will also accept 'force die', 'force-die', 'forcedie')
 *    'max_times=X': defines the maximum number of times debug() will be
 *                 called within a given loop
 *    'meta_level=X': cause the file name and line number to change to one
 *                 of the parent files/functions of the file/function
 *                 calling debug()
 *    'config':    configuration settings applied to debug();
 *    'return':    return value of output;
 */
function debug()
{
	$current_globals = debug__script_vars_only();
	$current_constants = debug__script_const_only();
	$output = '';
	$max_times = 0;
	$force_die = false;
	$continue = true;
	$included = debug_backtrace();
	$debug_line = $included[0]['line'];
	$debug_file = $included[0]['file'];
	unset($included);

	// ==================================================================
	// START: debug__max_times sub function


	// END: debug__max_times sub function
	// ==================================================================

	if( DEBUG__STATE === true || !defined('DEBUG__DISCONTINUE_'.$debug_line) )
	{
		$line = '';

		$through_put = '';
		$debug_args = func_get_args();
		$check_help_next = false;
		$debug_mode = DEBUG__MODE;

		for( $a = 0 ; $a < func_num_args() ; ++$a )
		{
			$var_name = array( 'name' => '' , 'extra' => '' , 'count' => 0 , 'space' => '' );
			$var_value = $debug_args[$a]; 
			//===============================================

			debug__get_var_name( $var_value , $var_name , $current_globals );
			debug__get_const_name( $var_value , $var_name , $current_constants );

			if(!empty($var_name['extra']))
			{
				$var_name['name'] .= '(or '.$var_name['extra'].') = ';
			}
			elseif($var_name['name'] != '')
			{
				$var_name['name'] .= '= ';
			};
			unset($var_name['extra'],$var_name['space'],$var_name['count']);
			$var_name = $var_name['name'];

			//===============================================
			$var_type = gettype($var_value);
			switch($var_type)
			{
				case 'string':
					switch(strtolower($var_value))
					{
						case 'help':
						case '?':
							$b = $a+1;
							$help_next = '';
							if(isset($debug_args[$b]) && is_string($debug_args[$b]))
							{
								switch($debug_args[$b])
								{
									case '':
										$help_next = $debug_args[$b];
										++$a;
										break;
								};
							};
							$var_name = debug__help($help_next);
							$var_value = '';
							unset($b , $help_next);
							break;
			
						case 'backtrace':
							$var_name = 'BACKTRACE: ';
							$var_value = debug_backtrace();
							break;

						case 'server':
							$var_name = '$_SERVER: ';
							$var_value = $_SERVER;
							break;

						case 'request':
							$var_name = '$_REQUEST: ';
							$var_value = $_REQUEST;
							break;

						case 'get':
							$var_name = '$_GET: ';
							$var_value = $_GET;
							break;

						case 'post':
							$var_name = '$_POST: ';
							$var_value = $_POST;
							break;

						case 'env':
							$var_name = '$_ENV: ';
							$var_value = $_ENV;
							break;

						case 'files':
							$var_name = '$_FILES: ';
							$var_value = $_FILES;
							break;

						case 'session':
							$var_name = '$_SESSION: ';
							$var_value = $_SESSION;
							break;

						case 'cookie':
							$var_name = '$_COOKIE: ';
							$var_value = $_COOKIE;
							break;

						case 'global':
						case 'globals':
							$var_name = '$GLOBALS: ';
							$var_value = $GLOBALS;
							break;

						case 'forcedie':
						case 'force die':
						case 'force_die':
						case 'force-die':
							$force_die = true;
							$line = '';
							$var_value = '';
							$var_name = '';
							break;

						case 'return':
							$debug_mode = 'return';
							$var_value = '';
							$var_name = '';
							break;
						case 'config':
//							$var_value = 'Sorry this functionality hasn\'t been implemented yet';
							$var_name = 'Debug configuration constants = ';
							$var_value = array();
							$current_const = get_defined_constants();
							{	
								foreach($current_const as $const_name => $const_value)
								{
									if(preg_match('/^DEBUG_/',$const_name))
									{
										$var_value[$const_name] = $const_value;
									};
								};
							};
							break;

						case 'constant':
						case 'constants':
							debug__get_const_name( $var_value , $var_name , $current_constants , true );
							break;

						default:
							if(preg_match('/^(max[- _]?times|meta[- _]?level) ?(?:= ?)?([0-9]*)$/' , $var_value , $matches))
							{
								switch($matches[1])
								{
									case 'maxtimes':
									case 'max-times':
									case 'max times':
									case 'max_times':
										if(!isset($matches[2]) || empty($matches[2]))
										{
											$max_times = DEBUG__MAX_MAX_TIMES;
										}
										else
										{
											$max_times = $matches[2];
										}
										$continue = debug__max_times( $max_times , $debug_line , $debug_file );
										$line = '';
										$var_value = '';
										$var_name['name'] = '';
										break;
									case 'metalevel':
									case 'meta-level':
									case 'meta_level':
									case 'meta level':
										$included = debug_backtrace();
										if(isset($matches[2]))
										{
											$meta_max = count($included);
											if( $matches[2] < $meta_max )
											{
												$meta_level = $matches[2];
											}
											else
											{
												$meta_level = $meta_max - 1;
											};
											$debug_line = $included[$meta_level]['line'];
											$debug_file = $included[$meta_level]['file'];
											unset($meta_max,$meta_level);
										};
										unset($included);
										$var_value = '';
										$var_name['name'] = '';
										break;
								};

							}
							elseif( $var_value === '' )
							{
								$var_value = '"" (empty string)';
								if($var_name == '')
								{
									$var_name = '[STRING]: ';
								};
							}
							else
							{
								$var_value = debug__special_chars($var_value);
								if($var_name == '')
								{
									$var_name = '[STRING]: ';
								};
							};
						break;
					};
					break;

//				case 'array':	// because $var_type = 'string' sometimes causes
//					break;	// $var_value to become an array. We check if it
//						// is an array outside this switch statement.

				case 'boolean':
					if( $var_value === false)
					{
						$var_value = 'FALSE';
					}
					elseif( $var_value === true)
					{
						$var_value = 'TRUE';
					};
					if($var_name == '')
					{
						$var_name = '['.strtoupper($var_type).']: ';
					}
					else
					{
						$var_value .= " ($var_type)";
					}
					break;

				case 'integer':
				case 'double':
				case 'unknown type':
				case 'NULL':
					if($var_name == '')
					{
						$var_name = '['.strtoupper($var_type).']: ';
					}
					else
					{
						$var_value .= " ($var_type)";
					}
					break;

				case 'object':
				case 'resource':
					$var_value = $var_type;
					break;
			};

			if(is_array($var_value))
			{
				$var_value = print_r($var_value,true);
				$var_value = debug__special_chars($var_value);
			};
			
			$through_put .= $line.$var_name.$var_value;
			$line = '[[line]]';
		};

		if($continue === true)
		{
			// ==================================================================
			// START: debug__wrap_text sub function

			$output = debug__wrap_text( $through_put , $debug_line , $debug_file , $debug_mode );

			// END: debug__wrap_text sub function
			// ==================================================================

			// ==================================================================
			// START: debug__die sub function

			debug__die( $max_times , $force_die , $debug_line , $debug_file );

			// END: debug__die sub function
			// ==================================================================
		};
	};

	if(!empty($output))
	{
		return $output;
	};
};

/**
 * @function debug_conf() defines configuration constants used by debug() and its sub functions
 * @param $varX string
 */
function debug_conf()
{
	if( !defined('DEBUG__CONF') )
	{
		$enviro_tmp = func_get_args();

		error_reporting( E_ALL | E_STRICT );

		$config = array(
			 'status' => true
			,'show_file' => true
			,'show_date' => false
			,'show_time' => false
			,'format' => 'auto' // html, text, comment, log, auto
			,'mode' => 'echo' // echo, return, log
			,'full_path' => false
			,'log_file' => ''
			,'root_path' => ''
			,'time_adjust' => 0
			,'timezone' => 'Australia/Sydney'
			,'meta_max_length' => 40
			,'max_max_times' => 100
		);
		debug__info($config);

		if(version_compare(phpversion(), '5.1.0') == 1 && $config['time_adjust'] == 0 )
		{
			$server_time = time();
			if(date_default_timezone_set($config['timezone']))
			{
				$local_time = time();
				$config['time_adjust'] = ($server_time - $local_time);
			};
			unset($server_time,$local_time);
		}
		elseif( $config['time_adjust'] < 13 )
		{ // time adjustment is probably in hours
			$config['time_adjust'] = ( $config['time_adjust'] * 3600 );
		}
		elseif( $config['time_adjust'] >= 13 && $config['time_adjust'] < 780 && is_int($config['time_adjust'] / 15 ) )
		{ // time adjustment is probably in minutes
			$config['time_adjust'] = ( $config['time_adjust'] * 60 );
		};

		foreach($enviro_tmp as $setting)
		{
			$setting = strtoupper($setting);
			switch($setting)
			{
				case 'DEBUG__OFF':
					$config['status'] = false;
					break;
				case 'HIDE_FILE':
					$config['show_file'] = false;
					break;
				case 'TEXT':
				case 'TXT':
					$config['format'] = 'text';
					break;
				case 'XHTML':
				case 'HTML':
				case 'HTM':
					$config['format'] = 'html';
					break;
				case 'COMMENT':
					$config['format'] = 'comment';
					break;
				case 'RETURN':
					$config['mode'] = 'return';
				case 'LOG':
				case 'LOG_CLEAN':
				case 'CLEAN':
					$config['mode'] = 'log_clean';
					break;
				case 'APPEND':
				case 'LOG_APPEND':
					$config['mode'] = 'log_append';
				case 'FULL_PATH':
					$config['full_path'] = true;
					break;
				case 'TIME':
					$config['show_time'] = true;
					break;
				case 'DATE':
					$config['show_date'] = true;
					break;
				default:if( is_writable($setting) )
					{
						if( is_file($setting) )
						{
							$config['log_file'] = $setting;
						}
						elseif( is_dir($setting) )
						{
							preg_match('/[\\/]/',$setting,$slash);
							$setting = preg_replace('/\\'.$slash[0].'$/','',$setting);
							$config['log_file'] = $setting.$slash[0].'.__DEBUG__LOG.txt';
						};
					}
					elseif(is_numeric($setting))
					{
						$config['meta_max_length'] = round($setting);
					}
					elseif( preg_match('/^time[-_ ]adjust=([0-9]+(?:\.[0-9]{2})?)$/i',$setting,$matches))
					{
						$config['time_adjust'] = $matches[1];
					};
					break;
			};
		};

		if(defined('DEBUG__STATUS'))
		{
			$status = debug__status_check(DEBUG__STATUS);
			switch(strtolower(DEBUG__STATUS))
			{
				case true:
				case 'on':
				case 'debug':
				case 'dev':
				case 'test':
				case 'testing':
					$status = true;
					break;
				case 'debug':
					if(isset($_GET['debug']))
					{
						if( $_GET['debug'] == 'true' || $_GET['debug'] == 'debug' )
						{
							$status = true;
						}
						else
						{
							$status = false;
						};
					};
					break;
				case false:
				case 'off':
					$status = false;
					break;

			};
		};

		if( $config['format'] == 'log' )
		{
			$config['mode'] = 'log_clean';
			$config['format'] = 'text';
		};

		if(isset($_SERVER['PWD'])) // running via the command line
		{
			$config['root_path'] = $_SERVER['PWD'].'/';
			if($config['format'] == 'auto')
			{
				$config['format'] = 'text';
			};
		}
		elseif(isset($_SERVER['SCRIPT_FILENAME'])) // running via the web
		{
			$config['root_path'] = dirname($_SERVER['SCRIPT_FILENAME']).'/';
			if($config['format'] == 'auto')
			{
				$config['format'] = 'html';
			};
		}
		else
		{
			$backtrace = debug_backtrace();
			$bt_count = count($backtrace) - 1;
			$config['root_path'] = dirname($backtrace[$bt_count]['file']).'/';
			if($config['format'] == 'auto')
			{
				$config['format'] = 'html';
			};
		};

		if(ob_get_level() > 1 )
		{
			if($config['mode'] != 'log_append')
			{
				$config['mode'] = 'log_clean';
			};
			$config['format'] = 'text';
		};

		debug__define('DEBUG__STATE',$config['status']);
		debug__define('DEBUG__MODE',$config['mode']);
		debug__define('DEBUG__FORMAT',$config['format']);	
		debug__define('DEBUG__FULL_PATH',$config['full_path']);
		debug__define('DEBUG__SHOW_FILE',$config['show_file']);
		debug__define('DEBUG__SHOW_TIME',$config['show_time']);
		debug__define('DEBUG__SHOW_DATE',$config['show_date']);
		debug__define('DEBUG__ROOT_PATH',$config['root_path']);
		debug__define('DEBUG__META_MAX_LENGTH',$config['meta_max_length']);
		debug__define('DEBUG__MAX_MAX_TIMES',$config['max_max_times']);
		debug__define('DEBUG__TIME_ADJUST',$config['time_adjust']);

		// ==================================================================
		// START: debug__initialise_txt_wrapper()

		debug__initialise_txt_wrapper();

		// END: debug_intialise_txt_wrapper()
		// ==================================================================

		// ==================================================================
		// START: debug__log_initialise sub function

		debug__log_initialise($config['log_file']);

		// END: debug__log_initialise sub function
		// ==================================================================

		// ==================================================================
		// START: record predefined variable and constant names

		debug__compact_names( 'vars' );
		debug__compact_names( 'const' );

		// END: record predefined variable and constant names
		// ==================================================================

		define('DEBUG__CONF',true);
	};
};

/**
 * debug__define() checks if a constant has been defined and
 * then, if not, defines it.
 *
 * $constant_name =	string
 * $default_value =	mixed var (usually boolean)
 * $user_value =	mixed var (usually boolean)
 * $case_insensitive =	boolean
 *
 * returns true if function defines constant or
 *         false if the constant is already defined.
 */
function debug__define($constant_name , $value , $case_insensitive = false)
{
	if(!defined($constant_name))
	{
		if($case_insensitive !== false)
		{
			$case_insensitive = true;
		};

		define($constant_name , $value , $case_insensitive);
		return true;
	}
	else
	{
		return false;
	};
};

function debug__special_chars($input)
{
	if(DEBUG__FORMAT != 'text')
	{
		return htmlspecialchars($input);
	}
	else
	{
		return $input;
	};
};

/**
 * debug__status_check() checks the valuse of $test_status against
 * allowable parameters and returns true or false accordingly.
 *
 * @param $test_status mixed (string or boolean)
 * @return $status boolean
 */
function debug__status_check($test_status)
{
	$status = false;
	switch(strtolower($test_status))
	{
		case 'true':
		case 'on':
		case 'dev':
		case 'test':
		case 'testing':
			$status = true;
			break;
		case 'debug':
			if(isset($_GET['debug']))
			{
				if( $_GET['debug'] == 'true' || $_GET['debug'] == 'debug' )
				{
					$status = true;
				}
				else
				{
					$status = false;
				};
			};
			break;
	};
	return $status;
};


// ==================================================================
// The following functions have been commented in favour of
// incorporating them into the function they are called from.
//
// Although it is cleaner to code them as separate functions it's
// simpler to code them within the main function as they are only
// called once.
// ==================================================================



/**
 * @fuction debug__initialise_txt_wrapper() sets up the appropariate strings to wrap
 * various bits of the debug output in.
 *
 * defines three constants: 
 *	'DEBUG__MSG_WRAPPER' - the whole debug message wrapper
 *	'DEBUG__MSG_BREAK'  -  line break replacement
 *	'DEBUG__MSG_META'   -  line number and file name replacement string.
 * 
 * These constants will be used by debut__wrap_text()
 */
function debug__initialise_txt_wrapper()
{
	$current_file = '';
	$open = '';
	$close = '';
	$break = "\n[[LEADING_SPACE]]";
	$meta = '';

	if(!DEBUG__SHOW_FILE)
	{
		$current_file = '';
	}
	else
	{
		if(DEBUG__FULL_PATH)
		{
			$current_file = DEBUG__ROOT_PATH.'[[CURRENT_FILE]]';
		}
		else
		{
			$current_file = '[[CURRENT_FILE]]';
		}
	};
	if(empty($current_file))
	{
		$meta = 'Line [[LINE_NUMBER]] ';
	}
	else
	{
		$meta = $current_file.'  Line [[LINE_NUMBER]]';
	}
	if( DEBUG__SHOW_DATE === true )
	{
		$meta .= '  [[DATE]]';
	};
	if( DEBUG__SHOW_TIME == true )
	{
		$meta .= ' [[TIME]]';
	};
	$meta = '('.$meta.')';

	switch(DEBUG__FORMAT)
	{
		case 'text':
			$open = "\n-----------------------------------------------------------\n[[META]]";
			$close = "\n";
			break;
		case 'comment':
			$open = "\n<!--\n[[META]]\n";
			$close = "\n-->\n";
			break;
		case 'html':
			$open = "\n<pre class=\"debug-msg\"><strong>[[META]]</strong>";
			$close = "</pre>\n";
			break;
	};

	debug__define('DEBUG__MSG_WRAPPER',$open.'[[DEBUG__MESSAGE]]'.$close);
	debug__define('DEBUG__MSG_BREAK',$break);
	debug__define('DEBUG__MSG_META',$meta);

};



/**
 * debug__time_adjust() moves the server time forward or backward asi
 * appropriate then returns the corrected timestamp
 *
 * @return integer (timestamp)
 */
function debug__time_adjust()
{
	if( DEBUG__TIME_ADJUST > 0 )
	{
		$timestamp = ( $time() + DEBUG__TIME_ADJUST );
	}
	else
	{
		$timestamp = time();
	};
	
	return $timestamp;
};



/**
 * debug__log_initialise() sets up the log file to accecpt debug log info.
 *
 * @param $log_path string full path and name of log file.
 */
function debug__log_initialise( $log_path )
{
	$included = debug_backtrace();
	$root_file = ( count($included) - 1 );
	$debug_file = pathinfo($included[$root_file]['file']);
	$timestamp = debug__time_adjust();
	$heading = 'Debug output for '.$debug_file['basename'].' ('.date('Y-m-d H:i',$timestamp).')';
	$content = '';
	if(empty($log_path))
	{
		$log_path = $debug_file['dirname'].'/';
	};
	if( defined('DEBUG__HIDE_LOG') && DEBUG__HIDE_LOG === true )
	{
		$hide_log = '.';
	}
	else
	{
		$hide_log = '';
	};

	if( !empty($log_path) && is_dir($log_path) && is_readable($log_path) )
	{
		debug__define('DEBUG__LOG_FILE', $hide_log.'debug__log.'.preg_replace('/[^-a-z0-9_]/i','-',$debug_file['basename']));
		if(!file_exists(DEBUG__LOG_FILE))
		{
			$mode = 'log_clean';
		}
		else
		{
			$mode = DEBUG__MODE;
		};

		switch($mode)
		{
			case 'log_clean':
				switch(DEBUG__FORMAT)
				{
					case 'htm':
					case 'html':
						$content = '
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
		<title>'.$heading.'</title>
		
		<link rel="StyleSheet" href="comp_winner.css" type="text/css" media="all" />
	</head>
	<body>
		<h1>'.$heading.'</h1>
	</body>
</html>
';
						break;
					default:
						$content = "====================================================================\n$heading\n";
						break;
					
				};
				break;

			case 'log_append':
				$content = file_get_contents(DEBUG__LOG_FILE);
				switch(DEBUG__FORMAT)
				{
					case 'htm':
					case 'html':
						$content = str_ireplace('</body>',"\t<hr />\n\t\t<h1>$heading</h2>\n\t</body>",$content);
						break;
					default:
						$content .= "\n\n====================================================================\n$heading\n";
						break;
				};
		};
		if(!empty($content) && file_exists(DEBUG__LOG_FILE) && is_writable(DEBUG__LOG_FILE))
		{
			file_put_contents(DEBUG__LOG_FILE,$content);
		};
	}
	else
	{
		switch(DEBUG__MODE)
		{
			case 'log_clean':
			case 'log_append':
				$pre =  "\n<!-- ================================================================\n";
				$post = "\n================================================================= -->\n";
				if(empty($log_path))
				{
					echo $pre."You have said that debug should output to a log file but you have not\nspecified where the log file should be put$post";
				}
				elseif(!is_dir($log_path))
				{
					echo $pre."The \"$log_path\" directory you specified is not directory.$post";
				}
				elseif(!is_writable($log_path))
				{
					echo $pre."The \"$log_path\" directory you specified for debugging is not writable.$post";
				};
				exit;
				break;
		};

	};
};


/**
 * debug__info() defines debug config defaults based on values from debug.info file
 * makes it easier to config debug
 *
 * A debug.info file would look something like this:
 *-------------------------------------------------------------------
 *  ; debug info file - This file defines DEBUG config for the current app
 *
 *  status = debug; true / false / on / off / dev / test / testing / debug 
 *  ; (NOTE: "status = debug;" requires $_GET['debug'] to equal true or debug otherwise debugging is switched off
 *  show_file = true; true/false
 *  show_date = false; true/false
 *  show_time = false; true/false
 *  full_path = false; true/false
 *
 *  format = html; comment / html / log / text
 *  mode = echo; append / clean / echo / log / log_append / log_clean / return
 *  ;log_file = ; file name to output log to - if logging is active defaults to .debug__log.[initial file name]
 *
 *  ; time_adjust is the number of seconds (or minutes or hours) difference between the server time and your local time)
 *  ;time_adjust;
 *
 *  ; timezone string to be used by date_default_timezone_set()
 *  ; (see www.php.net/manual/en/timezones.php)
 *  ; default timezone is Australia/Sydney;
 *  ; NOTE: timezone is case sensitive
 *  ;timezone = Australia/Sydney;
 *  meta_max_length = 10;
 *  max_max_times = 13;
 *-------------------------------------------------------------------
 *
 */
function debug__info(&$config)
{
	if(file_exists('debug.info'))
	{
		$info = file_get_contents('debug.info');
		$info_regex = '/(?<=[\r\n]|^)([^;\t =\r\n]+)[\t ]+[:=][ \t]+([^ \t;\r\n]+)(?:;.*)?(?=[\r\n])/iU';
		preg_match_all($info_regex,$info,$matches,PREG_SET_ORDER);
		if(!empty($matches))
		{
			foreach($matches as $conf)
			{
				if(!empty($conf))
				{
					$key = strtolower($conf[1]);
					$value = strtolower($conf[2]);
					switch($key)
					{
						case 'status':
							$config[$key] = debug__status_check($value);
							break;
						case 'show_file':
						case 'show_date':
						case 'show_time':
						case 'full_path':
						case 'hide_log':
						case 'show_full_path':
							switch($value)
							{
								case 1:
								case '1':
								case 'true':
								case 'on':
									$config[$key] = true;
									break;
								case 0:
								case '0':
								case 'false':
								case 'off':
									$config[$key] = false;
									break;
							};
							break;
						case 'format':
							switch($value)
							{
								case 'comment':
								case 'log':
									$config[$key] = $value;
									break;
								case 'htm':
								case 'html':
								case 'xhtml':
									$config[$key] = 'html';
									break;
								case 'text':
								case 'txt':
									$config[$key] = 'text';
									break;
							};
							break;
						case 'mode':
							switch($value)
							{
								case 'echo':
								case 'return':
									$config[$key] = $value;
									break;
								case 'append':
								case 'log_append':
									$config[$key] = 'log_append';
									break;
								case 'clean':
								case 'log':
								case 'log_clean':
									$config[$key] = 'log_clean';
									break;
							};
							break;
						case 'log_file':
							if(is_file($conf[2]) && is_readable($conf[2]) && is_writable($conf[2]))
							{
								$config[$key] = $conf[2];
							};
							break;
						case 'timezone':
							$config[$key] = preg_replace('/[^a-z_\/]+/i' , '' , $conf[2]);
							break;
						case 'time_adjust':
						case 'meta_max_length':
						case 'max_max_times':
							if(is_numeric($value))
							{
								$config[$key] = $conf[2];
							};
							break;

					};
				};
			};
		};
	};
};


/**
 * debug__max_times() is defining how many times the debug() function
 * gets called in script before it stops outputting debug messages
 *
 * @param $max_times integer The maximum number of times this
 *        function can be called.
 * @return boolean true if debugging should be shown, false if not
 */

function debug__max_times($max_times,$debug_line,$debug_file)
{
	$output = null;
	if(!defined('DEBUG__DISCONTINUE_'.$debug_line))
	{
		if(!is_numeric($max_times))
		{
//			$max_times = 0;
			return;
		}
		elseif($max_times > DEBUG__MAX_MAX_TIMES)
		{
			$max_times = DEBUG__MAX_MAX_TIMES;
		};
		$time_id = preg_replace('/[^a-z0-9]+/i','_',$debug_file.'_'.$debug_line.'_');
		if( $max_times > 0 )
		{
			if( !defined('DEBUG__DO_'.$time_id.'1') )
			{
				while($max_times > 0)
				{
					if(!defined('DEBUG__DO_'.$time_id.$max_times))
					{
						define('DEBUG__DO_'.$time_id.$max_times,TRUE);
						$output = true;
					};
					--$max_times;
				};
				$output = false;
			}
			else
			{
				$output = false;
			};
		}
		else
		{
			$output = true;
		};
		if($output === false)
		{
			define('DEBUG__DISCONTINUE_'.$debug_line,true);
		};
	}
	else
	{
		return false;
	};
};




/**
 * debug__die() kills your script after debug() has been called a
 * specified number of times
 *
 * When $max_times has been exhausted, and force_die is true, this
 * kills the whole script. This is useful when trying to debug a
 * script with an infinite loop.
 * 
 * @param $max_times integer number of times debug should run
 * @param $force_die boolean kill the script or not.
 */

function debug__die( $max_times , $force_die , $debug_line , $debug_file)
{
	if(defined('DEBUG__DO_1') && $force_die === true)
	{
		if($max_times > 1)
		{
			$suffix = 's';
		}
		else
		{
			$suffix = '';
		};
		$message = 'debug() has killed your script after '.$max_times.' time'.$suffix.'. (at your request)';
		debug__die_with_info( $message , DEBUG__DIE_WITH_INFO__NO_VAR , 2 );
	};
};



/**
 * debug__die_with_info() output a message for invalid function input parameters to be used in a die() call.
 * It appends the line number and file name of the function with the invalid parameter was called from.
 * 
 * @param $message string output message to be used
 * @param $dead_input mixed input whose type is to be reported
 * @param $depth integer how far down the backtrace to get info.
 * @return string full die message with line number file name and input type (if supplied)
 *
 * @const DEBUG__DIE_WITH_INFO__NO_VAR unique no test variable value to ensure input type check is not matched incorrectly
 */

define('DEBUG__DIE_WITH_INFO__NO_VAR' , '{[ NO_INPUT_SUPPLIED - '.microtime().' ]}');
function debug__die_with_info( $message = '' , $dead_input = DEBUG__DIE_WITH_INFO__NO_VAR , $depth = 1 )
{
	if( !is_string($message) )
	{
		$output_msg = 'debug__die_with_info() expects first parameter 1 to be a string '.gettype($message).' found instad.';
		$depth = 0;
	}
	else
	{
		$output_msg = $message;
	};
	$back_trace = debug_backtrace();
	if( $dead_input != DEBUG__DIE_WITH_INFO__NO_VAR )
	{
		$output_msg .= ' '.gettype($dead_input).' found';
	};

	$output_msg .= " on line {$back_trace[$depth]['line']} of {$back_trace[$depth]['file']}.\n";

	if( $message == '' )
	{
		return $output_msg;
	}
	else
	{
		die($output_msg);
	};
};


/**
 * debug__log() writes debug output to log file
 *
 * @param $input string debugging info to be added to the log file.
 */

function debug__log(&$input)
{
	if( is_file(DEBUG__LOG_FILE) && is_readable(DEBUG__LOG_FILE) && is_writable(DEBUG__LOG_FILE))
	{
		switch(DEBUG__MODE)
		{
			case 'log':
			case 'log_clean':
			case 'log_append':
				switch(DEBUG__FORMAT)
				{
					case 'html':
					case 'htm':
						$log_content = file_get_contents(DEBUG__LOG_FILE);
						$output = str_ireplace('</body>',"\n$input\n\t</body>",$log_content);
						file_put_contents(DEBUG__LOG_FILE,$output);
						break;
					default:
						file_put_contents(DEBUG__LOG_FILE,$input,FILE_APPEND);
				};
		};
	};
};

/**
 * debug__wrap_text() applies formatting to the debug message.
 *
 * @param $msg string debug message to be displayed or logged
 *
 * @const DEBUG__MSG_WRAPPER string that will be used to format the
 *        whole message
 * @const DEBUG__MSG_META strng that will contain the file name and
 *        line number debug was called from.
 * @const DEBUG__MSG_BREAK string that will be used to substitute
 *        line break and leading white space
 */

function debug__wrap_text( &$msg , $debug_line , $debug_file , $debug_mode = DEBUG__MODE )
{
	$date = '';
	$time = '';
	$timestamp = debug__time_adjust();
	$wrapper = DEBUG__MSG_WRAPPER;

	if( DEBUG__SHOW_DATE === true )
	{
		$date = date(' Y-m-d',$timestamp);
	};
	if( DEBUG__SHOW_TIME == true )
	{
		$time = date(' H:i',$timestamp);
	};
	$debug_file = str_replace(DEBUG__ROOT_PATH,'',$debug_file);
	$meta = str_replace(
		 array( '[[LINE_NUMBER]]','[[CURRENT_FILE]]','[[DATE]]','[[TIME]]')
		,array($debug_line,$debug_file,$date,$time)
		,DEBUG__MSG_META
	);
	$meta_length = strlen($meta);

	if($meta_length > DEBUG__META_MAX_LENGTH)
	{
		$meta_length = 5;
		$meta .= '[[LINE]]';
	}
	else
	{
		$msg = ' '.$msg;
		$wrapper = str_replace(']][[' , ']] [[' , $wrapper);
	};
	$leading_space = '';
	for($a = $meta_length ; $a > 0 ; --$a )
	{
		$leading_space .= ' ';
	};
	$break = str_replace('[[LEADING_SPACE]]',$leading_space,DEBUG__MSG_BREAK);

	$output = str_ireplace(array('[[META]]','[[DEBUG__MESSAGE]]','[[LINE]]'),array($meta,$msg,$break),$wrapper);

	unset( $date , $time , $timestamp , $meta , $meta_length , $leading_space , $break );
	switch($debug_mode)
	{
		case 'log':
		case 'log_clean':
		case 'log_append':
			debug__log($output);
			break;
		case 'return':
			return $output;
			break;
		default:
			echo $output;
			break;
	};
	return '';
};


/**
 * debug__help() Outputs help info on how to use debug()
 *
 * @param $arr mixed:	'debug' - info about using debug()
 *			'conf'  - info about setting up environment
 *				  parameters for debug() (includes
 *				  both 'info' and 'debug__conf' plus
 *				  some extra stuff)
 *			'info'  - info about the info file
 *			'debug__conf'  - info about using debug__conf()
 *			NULL / empty array
 *				- everything
 *
 * Outputs everything to screen.
 */
function debug__help(&$arr)
{

	$content['debug']['title'] = '
<h2>Using <span class="function">debug()</span></h2>
';

	$content['debug']['menu'] = '';

	$content['debug']['content'] = '
<style type="text/css">
#debug__help { font-family: arial,helvetica,sans-serif; line-height:1.2em; }
#debug__help p.top-h2 { border-top: 0.1em solid #000; padding-top: 1em; margin: 3em 0% 0.5em 0%; }
 #debug__help h2
,#debug__help h3
,#debug__help h4
,#debug__help dl dt
,#debug__help p.note:first-child { font-family: verdana, arial, helvetica, sans-serif; }
#debug__help h2 { margin:0%; }
#debug__help dl.config dd { margin-top: -1.0em; margin-left: 8em; margin-bottom:1em; }
#debug__help dl.reserved dd { margin-top: -1.0em; margin-left: 9em; margin-bottom:1em; }
#debug__help dl.config dd.wide { margin-top: -1.2em; margin-left: 11.5em; }
#debug__help dl.config dd samp { font-size: 120%; padding-right: 1em; display:block; margin-bottom: -1.3em; }
#debug__help dl.config dd span { display:block; margin-left:7em; margin-bottom: 1.2em; }
#debug__help dl.config dd span.wide { margin-left:6em; text-indent: 5em; }
#debug__help dl.config dd.wide span { margin-left:3.5em; }
#debug__help dl dt { font-weight: bold; font-size: 105%; margin-top: 1.5em; }
 #debug__help dl.config dd samp:after
,#debug__help dl.config dd samp:before { content: \'"\'; }
#debug__help dl.config dd.default samp { font-weight: bold; }
#debug__help pre#info { border: 0.1em solid #000; padding:1em 1em 1em 3em; width: 50em; background-color:#eee; }
#debug__help p.info-info strong samp { font-size: 130%; color: #007; padding: 0% 0.3em; }
#debug__help pre.samp { border:0.1em dashed #0c0; padding: 1em; background-color: #efe; }
#debug__help pre.output { border:0.1em dotted #00c; padding: 1em; background-color: #eef; }
#debug__help p.note { margin-left: 3.3em; text-indent:-3.3em; }
#debug__help p.note strong { padding-right:0.5em;; }
	</style>
<div id="debug__help">
	<h1 id="top">debug() documentation</h1>

	<ul>
		<li><a href="#auth">Author and copyright</a></li>
		<li><a href="#intro">Introduction</a></li>
		<li><a href="#install">Installation</a></li>
		<li><a href="#basic">Basic usage</a>
			<ul>
				<li><a href="#basic">Most common usage</a></li>
				<li><a href="#normal">Normal usage</a></li>
				<li><a href="#simple">Simplest usage</a></li>
			</ul>
		</li>
		<li><a href="#special">Reserved strings</a></li>
		<li><a href="#advanced">Advanced usage</a>
			<ul>
				<li><a href="#advanced">Unlimited arguments</a></li>
				<li><a href="#max_times">max_times</a></li>
				<li><a href="#force_die">force_die</a></li>
				<li><a href="#meta_level">meta_level</a></li>
			</ul>
		</li>
		<li><a href="#config">Configuration</a>
			<ul>
				<li><a href="#options">Options</a></li>
				<li><a href="#sample-config">Sample Config file</a></li>
			</ul>
		</li>
	</ul>

	<p class="top-h2"><a href="#top" name="auth">top</a></p>
	<h2>Author and copyright</h2>

	<p>This script was written by Evan Wills with technical assistance and advice from Trevor Goodall, Brent Knigge and Ivan Wills.</p>
	<p>It is released under the GPL2</p>

	<p class="top-h2"><a href="#top" name="intro">top</a></p>
	<h2>Introduction</h2>

	<p><samp>debug()</samp> is intended make it easy to output debug messages when developing or debugging a PHP script.</p>

	<p>By default it outputs to screen the original calling script\'s file name, the line number the debug function is called from and the actual debug message or the name of a supplied variable and it\'s value. The script should handle any type of variable and will, depending on the type identify, that variable\'s type.</p>

	<p>debug() can accept any number of arguments. The value of each argument along with its variable name (if there is one) will be printed on a new line.</p>

	<p class="top-h2"><a href="#top" name="install">top</a></p>
	<h2>Installation</h2>

	<p>To make debug() work all you need to do is include debug.inc.php in your script (preferably as early possible)</p>

	<p>To get the most out of it, you should also have a custom copy of <samp>debug.info</samp> in the same directory/folder as the calling script (same directory as <samp>$_SERVER[SCRIPT_NAME]</samp>)</p>

	<p class="top-h2"><a href="#top" name="basic">top</a></p>
	<h2>Basic usage</h2>

	<h3>Most common usage</h3>
	<p>The most comon usage for debug() is to output the value of a variable (at least that\'s how I mostly use it)</p>
	<div class="example">
	<pre class="samp"><samp>$var1 = array( \'string\', 123643, true );</samp>
<samp>define(\'CONST_1\',\'this is a const\');
<samp>debug($var1);debug(CONST_1);</samp></pre>
		<p>This will output</p>
		<pre class="output"><strong>(my_script.php Line 231)</strong>
    $var1 = Array
(
    [0] =&gt; \'string\'
    [1] =&gt; 123643
    [2] =&gt; 1
)

<strong>(my_script.php Line 231)</strong>
    CONST_1 = this is a const</pre>
	</div>
	<p class="note"><strong>Note:</strong> The variable (and constant) names are shown. This relies on the finding an identical match for the variable\'s (or constant\'s) value and type. Depending on your coding style it may list all the possible variables (and/or constants) you have assigned that value to. If there are a number of variables (or constants) with identical values, it will list the names of all them in order of assignment. This is particularly an issue if you have a number of variables (or constants) with either an empty string or boolean or NULL values.</p>

	<p class="note"><strong>Note:</strong> Because constants are global and PHP creates so many when it starts (and because debug() itself creates a few of it\'s own constants), this script excludes all constants created before the end of debug.inc.php. This is so you don\'t end up with 10 or 20 constant names who\'s values also match PHP defined constants. If you are using constants (and even if you\'re not) you should include debug.inc.php as early as possible in the script.</p>

	<p class="top"><a href="#top" name="normal">top</a></p>
	<h3>Normal usage</h3>
	<p>Often when debugging you just want to let yourself know you\'ve reached a given point in the script and that something has happened. If you just want to output a string:</p>

	<div class="example">
		<pre class="samp"><samp>debug(\'this is a debug message\');</samp></pre>
		<p>This will output</p>
		<pre class="output"><strong>(my_script.php Line 231)</strong>
    this is a debug message</pre>
	</div>

	<p class="top"><a href="#top" name="simple">top</a></p>
	<h3>Simplest usage</h3>
	<p>Sometimes all you need to know is that the script has processed a given line. If that is the case just call debug() with no arguments</p>

	<div class="example">
		<pre class="samp"><samp>debug();</samp></pre>
		<p>This will output</p>
		<pre class="output"><strong>(my_script.php Line 231)</strong></pre>
	</div>

	<p class="top-h2"><a href="#top" name="special">top</a></p>
	<h2>Reserved strings</h2>
	<p>There are a number of reserved strings that if passed will cause debug() to do special things.</p>
	<p class="note"><strong>Note:</strong> these reserved strings are case insensitive.</p>
	<dl class="reserved">
		<dt>help or \'?\'</dt>
			<dd>Outputs help documentation about the debug function</dd>
		<dt>backtrace</dt>
			<dd>Outputs the contents of an array generated by debug_backtrace()</dd>
		<dt>server</dt>
			<dd>Outputs the contents of the $_SERVER global array</dd>
		<dt>request</dt>
			<dd>Outputs the contents of the $_REQUEST global array</dd>
		<dt>get</dt>
			<dd>Outputs the contents of the $_GET global array</dd>
		<dt>post</dt>
			<dd>Outputs the contents of the $_POST global array</dd>
		<dt>env</dt>
			<dd>Outputs the contents of the $_ENV global array</dd>
		<dt>files</dt>
			<dd>Outputs the contents of the $_FILES global array</dd>
		<dt>session</dt>
			<dd>Outputs the contents of the $_SESSION global array</dd>
		<dt>cookie</dt>
			<dd>Outputs the contents of the $_COOKIE global array</dd>
		<dt>globals</dt>
			<dd>Outputs the contents of the $GLOBALS global array (will also accept global)</dd>
		<dt>max_times=X</dt>
			<dd>defines the maximum number of times debug() will be called within a given loop</dd>
			<dd>(will also accept "max times = X", "maxtimes =X", "max-times X" (<strong>note:</strong> spaces, hyphens and underscores can be used inter-changably or omitted. equals can also be omitted)</dd>
			<dd>(see <a href="#max_times">Advanced usage &gt; max_times for more info</a>)</dd>
		<dt>force_die</dt>
			<dd>cause the debug function to kill the script after a given number of times (defined by max_times)</dd>
			<dd>(will also accept \'force die\', \'force-die\', \'forcedie\')</dd>
			<dd>(see <a href="#force_die">Advanced usage &gt; force die for more info</a>)</dd>
		<dt>meta_level=X</dt>
			<dd>cause the file name and line number to change to one of the parent files/functions of the file/function calling debug()</dd>
			<dd>(will also accept "meta level = X", "metalevel =X, "meta-level X" (<strong>note:</strong> as with max_times, spaces, hyphens and underscores can be used inter-changably or omitted. equals can also be omitted)</dd>
			<dd>(see <a href="#meta_level">Advanced usage &gt; meta_level for more info</a>)</dd>
		<dt>config</dt>
			<dd>Outputs configuration info for debug()</dd>
			<dd>(NOTE: this has not been implemented yet so it will only tell you that it hasn\'t been implmented)
	</dl>

	<p class="top-h2"><a href="#top" name="advanced">top</a></p>
	<h2>Advanced usage</h2>
	<h3>Unlimited arguments</h3>
	<p>debug() can accept an unlimited number of arguments, in any order. Each supplied argument is handled individually (see <a href="#exception">exception</a>) and can be of any type.</p>
	<p>As each argument is processed, it is checked for type and handled appropriately. Then output starting on a new line</p>

	<div class="example">
		<pre class="samp"><samp>$var1 = array( \'string\', 123643, true );</samp>
<samp>$var2 = 1234589.32;</samp>

<samp>debug($var1,\'server\',\'post\',This is a debug function call\',$var2);</samp></pre>
		<p>This will output</p>
		<pre class="output"><strong>(my_script.php Line 231)</strong>
$var1 = Array
(
    [0] =&gt; string
    [1] =&gt; 123643
    [2] =&gt; 1
)

$_SERVER: Array
(
    [HTTP_HOST] =&gt; localhost
    [HTTP_USER_AGENT] =&gt; Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.2.12) Gecko/20101027 Ubuntu/10.04 (lucid) Firefox/3.6.12
    [HTTP_ACCEPT] =&gt; text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    [HTTP_ACCEPT_LANGUAGE] =&gt; en-us,en;q=0.5
    [HTTP_ACCEPT_ENCODING] =&gt; gzip,deflate
    [HTTP_ACCEPT_CHARSET] =&gt; ISO-8859-1,utf-8;q=0.7,*;q=0.7
    [HTTP_KEEP_ALIVE] =&gt; 115
    [HTTP_CONNECTION] =&gt; keep-alive
    [HTTP_REFERER] =&gt; http://localhost/eNewsletter-prep/
    [HTTP_PRAGMA] =&gt; no-cache
    [HTTP_CACHE_CONTROL] =&gt; no-cache
    [CONTENT_TYPE] =&gt; application/x-www-form-urlencoded
    [CONTENT_LENGTH] =&gt; 101
    [PATH] =&gt; /usr/local/bin:/usr/bin:/bin
    [SERVER_SIGNATURE] =&gt; <address>Apache/2.2.14 (Ubuntu) Server at localhost Port 80</address>
    [SERVER_SOFTWARE] =&gt; Apache/2.2.14 (Ubuntu)
    [SERVER_NAME] =&gt; localhost
    [SERVER_ADDR] =&gt; ::1
    [SERVER_PORT] =&gt; 80
    [REMOTE_ADDR] =&gt; ::1
    [DOCUMENT_ROOT] =&gt; /var/www
    [SERVER_ADMIN] =&gt; webmaster@localhost
    [SCRIPT_FILENAME] =&gt; /var/www/eNewsletter-prep/index.php
    [REMOTE_PORT] =&gt; 51515
    [GATEWAY_INTERFACE] =&gt; CGI/1.1
    [SERVER_PROTOCOL] =&gt; HTTP/1.1
    [REQUEST_METHOD] =&gt; POST
    [QUERY_STRING] =&gt; 
    [REQUEST_URI] =&gt; /eNewsletter-prep/
    [SCRIPT_NAME] =&gt; /eNewsletter-prep/index.php
    [PHP_SELF] =&gt; /eNewsletter-prep/index.php
    [REQUEST_TIME] =&gt; 1290144742
)

$_POST: Array
(
    [template] =&gt; ACU_Update_2009
    [submit] =&gt; Prepare email
    [ga_source] =&gt; 
    [ga_medium] =&gt; 
    [ga_campaign] =&gt; 
    [ga_content] =&gt; 
    [ga_term] =&gt; 
)

This is a debug function call
$var2 = 1234589.32 (double)</pre>
	</div>
	<p class="top"><a href="#top" name="max_times">top</a></p>
	<h3>max_times</h3>
	<p>By calling debug(\'max_times=X\'); from within a loop you cause that instance of debug() to output only the supplied number of times (or if no number is supplied, the default maximum number of times.</p>
	<p>How does it do this you might ask without using global variables or objects. Well it does it by creating a constant for every time that instance of debug() is called until the maximum is reached.</p>
	<p>You can have any number of max_times set, as they are independant.</p>
	<p>The default for max_times is 100 but can be raised or lowerd via the debug.info config file (see more on <a href="#config">debug.info</a>)</p>

	<p class="top"><a href="#top" name="force_die">top</a></p>
	<h3>force_die</h3>
	<p>
		If your script is getting stuck in an infinite loop you can use debug(\'max_times=30\',\'force_die\') to kill the script after a given number calles to the debug() function from a specific line (in this case 30 times)<br />
		<strong>NOTE:</strong> this functionality has <strong>not</strong> be exhaustively tested. In all my testing it has worked but...)
	</p>
	<p>(<strong>Note:</strong> force_die cannot work without max_times being defined in the same function call)</p>


	<p class="top"><a href="#top" name="meta_level">top</a></p>
	<h3>meta_level</h3>
	<p>Sometimes you might want to use debug as part of a normal function. By default the metadata output by debug() is the file name and line where debug() is called from but if you are using it within a function you probably want to find out where the calling function is being called from. If so by passing \'meta_level=X\' as one of your debug() arguments you can specify where abouts the debug reports from.</p>
	<p>The levels are as follows:</p>
	<dl class="reserved">	
		<dt>meta_level=0</dt>
			<dd>The place where debug() is called (This is the default for debug())</dd>
		<dt>meta_level=1</dt>
			<dd>The parent file or function calling the place where debug() is called.</dd>
		<dt>meta_level=2</dt>
			<dd>parant\'s parents of the calling function or file.</dd>
	</dl>
	<p class="note"><strong>Note:</strong> If X is greater than the maximum number of parents, \'meta_level=X\' will default to the original calling script details.</p>



	<p class="top-h2"><a href="#top" name="config">top</a></p>
	<h2>Configuration</h2>
	<p>By default debug() outputs directly to screen in HTML format but this can be over ridden by having a debug.info file in the same directory/folder as the script being run (same directory/folder as <samp>$_SERVER[SCRIPT_NAME]</samp>).</p> 

	<p class="top"><a href="#top" name="options">top</a></p>
	<h3>Options</h3>
	<p>(<strong>Note:</strong> default values are in bold)</p>


	<dl class="config">
		<dt>status</dt>
			<dd class="default">
				<samp>true</samp>
				<span>Always show debug() output</span>
			</dd>
			<dd>
				<samp>false</samp>
				<span>never show debug output</span>
			</dd>
			<dd>
				<samp>debug</samp>
				<span>Only show debug() output if $_GET[\'debug\'] is set and equals true.<br />(Useful for debugging live or production scripts)</span>
			</dd>
		<dt>show_file</dt>
			<dd class="default">
				<samp>true</samp>
				<span>Show name of file currently being processed in debug output.<br />(Useful if you are working with a script with multiple inlcudes)</span>
			</dd>
			<dd>
				<samp>false</samp>
				<span>Never show current file name</span>
			</dd>
		<dt>show_date</dt>
			<dd class="default">
				<samp>false</samp>
				<span>Never show today\'s date</span>
			</dd>
			<dd>
				<samp>true</samp>
				<span>Show today\'s date in debug() output.<br />(Useful if you\'ve got other people testing a script and you\'re writing debug output to a log file)</span>
			</dd>
		<dt>show_time</dt>
			<dd class="default">
				<samp>false</samp>
				<span>Never show the time debug() is called</span>
			</dd>
			<dd>
				<samp>true</samp>
				<span>Show the time in the debug() output.<br />(Useful if you\'re trying to work out where your script is slow or if you\'re writing to log file)</span>
			</dd>
		<dt>format</dt>
			<dd class="default">
				<samp>html</samp>
				<span>Format debug() output as HTML (recommended if you\'re testing via a browser)</span>
			</dd>
			<dd>
				<samp>text</samp>
				<span>Format debug() output in plain text.<br />(Useful if you\'re testing from the command line or writing to a log file)</span>
			</dd>
			<dd>
				<samp>comment</samp>
				<span>Format debug() output as plain text but Wrap it in HTML comments.<br />(Useful if you\'re debugging a live script and don\'t want people to see the inappropriate stuff)</span>
			</dd>
			<dd>
				<samp>log</samp>
				<span>Same as text</span>
			</dd>
		<dt>mode</dt>
			<dd class="default">
				<samp>echo</samp>
				<span>Display debug() output to screen (or terminal) (normal if \'format\' is HTML or comment</span>
			</dd>
			<dd>
				<samp>return</samp>
				<span>Return debug() output as a string to be used elsewhere in your code</span>
			</dd>
			<dd>
				<samp>log</samp>
				<span>Write debug() output to an empty log file</span>
			</dd>
			<dd>
				<samp>log-clean</samp>
				<span>same as log</span>
			</dd>
			<dd>
				<samp>clean</samp>
				<span>same as log</span>
			</dd>
			<dd>
				<samp>log-append</samp>
				<span>Append debug() output to an existing log file</span>
			</dd>
			<dd>
				<samp>append</samp>
				<span>same as log-append</span>
			</dd>
		<dt>full_path</dt>
			<dd class="default">
				<samp>false</samp>
				<span>Never show full path for current file</span>
			</dd>
			<dd>
				<samp>true</samp>
				<span>Show full/absolute path to current file<br />(Useful if you\'re including php files outside the directory the original script is called from)<br />(NOTE: this only works if you\'ve got \'show_file\' set to TRUE)</span>
			</dd>
		<dt>log_file</dt>
			<dd>
				<samp>[empty]</samp>
				<span>The file name to output log to (if logging is active it defaults to ".debug__log.[CALLING SCRIP\'S NAME].log"</span>
			</dd>
	<!--	<dt>root_path</dt>
			<dd>
				<samp>[empty]</samp>
				<span></span>
			</dd>
-->
		<dt>time_adjust</dt>
			<dd>
				<samp>0</samp>
				<span>The number of seconds (or minutes or hours) difference between the server time and your local time.<br />(this is only useful if your server is <strong>NOT</strong> set to GMT or your local time)</span>
			</dd>
		<dt>timezone</dt>
			<dd class="default">
				<samp>Australia/Sydney</samp>
				<span class="wide">
					timezone string to be used by <code>date_default_timezone_set()</code><br />
					<strong>NOTE:</strong> timezone is case sensitive<br />
					(See <a href="/timezones.php">PHP\'s Timezone documentation for other timezones</a>)
				</span>
			</dd>
		<dt>meta_max_length</dt>
			<dd class="wide">
				<samp>40</samp>
				<span>the maximum number of total characters the file name, line number, date and time can be before the debug output is pushed to a new line</span>
			</dd>
		<dt>max_max_times</dt>
			<dd class="wide">
				<samp>100</samp>
				<span>
					if the max-times option is passed for a particular debug() call, max_max_times is the default maximum number of times a that particular call to debug() will be rendered within a loop.<br />
					<strong>NOTE:</strong> if force-die is also passed, when the max-times is reach the script will stop processing all together. This is to help debug scripts with infinite loops.
				</span>
			</dd>
	</dl>

	<p class="top"><a href="#top" name="sample-config">top</a></p>
	<h3>Sample config file</h3>

	<p class="info-info">This file must be named <strong><samp>debug.info</samp></strong> and should be in the same directory/folder that the original script is called from.</p>
	<pre id="info">
; debug info file - This file defines DEBUG config for the current app

; -----------------------------------------------
; status defines whether or not debug will output
; anything.
; The options are:
;   \'tru\' (default) or\'o\' or\'tes\' or\'testin\' -
;          debug() will always be shown if called
;   \'fals\' or\'of\' - debug() will never be
;          shown
;   \'debu\' - debug() will only be shown if
;          $_GET\'debu\'] is set and equal to
;          TRUE or\'debu\'

status = true;


; -----------------------------------------------
; format defines how the debug output will be
; written.
; The options are:
;    \'htm\' (default) - Use HTML to mark up the
;          debug output
;    \'commen\' - wrap the output in HTML comment
;          tags
;    \'tex\' or\'lo\' - render the output of
;          debug() in plain text

format = html; comment / html / log / text


; -----------------------------------------------
; mode defines where the output of debug is
; rendered. i.e. is it rendered to screen, to a
; log file or returned as a string for use
; elsewhere.
; The options are:
;    \'appen\' or\'log_appen\' - add to an
;          existing log file
;    \'clea\' or\'lo\' or\'log_clea\' - add to an
;          empty log file
;    \'ech\' (default) - render to screen
;    \'retur\' - returned by the debug function
 
mode = echo; append / clean / echo / log / log_append / log_clean / return


; -----------------------------------------------
; show_file defines whether the name of the file
; debug() is being called from is rendered in the
; debug output.
; The options are:
;     true (default) or false

show_file = true; true/false


; -----------------------------------------------
; show_date defines whether the current date is
; rendered in the debug output.
; The options are:
;     true or false (default)

show_date = false; true/false


; -----------------------------------------------
; show_time defines whether the time a debug()
; call is parsed is rendered in the debug output.
; The options are:
;     true or false (default)

show_time = false; true/false


; -----------------------------------------------
; full_path defines whether the full path to the
; current file being processed is rendered in the
; debug output.
; (Note: This is only relevant if show_file is
;  set to TRUE)
; The options are:
;     true or false (default)

full_path = false;


; -----------------------------------------------
; log_file is the file name to output log to. If
; logging is active it defaults to 
; .debug__log.[initial file name].log
;log_file = ;


; -----------------------------------------------
; time_adjust is the number of seconds (or minutes
; or hours) difference between the server time
; and your local time)

;time_adjust 36000; 10 hours


; -----------------------------------------------
; timezone string to be used by
; date_default_timezone_set()
; (see www.php.net/manual/en/timezones.php)
; default timezone is Australia/Sydney;
; NOTE: timezone is case sensitive

timezone = Australia/Sydney;


; -----------------------------------------------
; meta_max_length is the maximum number of total
; characters the file name, line number, date and
; time can be before the debug output is pushed
; to a new line.

meta_max_length = 10;


; -----------------------------------------------
; if the max-times option is passed for a
; particular debug() call, max_max_times is the
; default maximum number of times a that
; particular call to debug() will be rendered
; within a loop.
; NOTE: if force-die is also passed, when the
;       max-times is reach the script will stop
;       processing all together. This is to help
;       debug scripts with infinite loops.

max_max_times = 13;</pre>
</div>
';
	$output = '';
	$help_mode = debug__help_mode($arr);
/*	if(isset($$help_mode))
	{
		echo "<h2>".$content[$help_mode]['title']."</h2>\n".$content[$help_mode]['menu']."\n\n".$content[$help_mode]['content'];
	}
	else
	{
		$menu = '<ul>';
		$output = '<hr />';
		foreach($content as $mode)
		{
			$menu .= "\n<li>{$mode['title']}\n{$mode['menu']}\n</li>\n";
			$output .= "\n\n{$mode['content']}\n\n";
		};
		echo "$menu</ul>\n\n$output";
	};
*/
	echo $content['debug']['content'];
};
/**
 * debug__help_mode() is a recursive that cascades through an array
 * looking for a valid help mode value then returns that value.
 *
 * @param $arr mixed string or array
 * @return string
 */
function debug__help_mode($arr,&$end = false)
{
	$output = '';
	if( $end == false )
	{
		$help_mode = '';
		if( is_array($arr) )
		{
			if( !empty($arr) )
			{
				for($a = 0 ; $a < count($arr) ; ++$a)
				{
					$help_mode = debug__help_mode($arr[$a],$end);
					if($end === true)
					{
						$a = count($arr);
					};
				};
			};
		}
		else
		{
			$help_mode = $arr;
		};

		$help_mode = strtolower($help_mode);
		switch($help_mode)
		{
			case 'debug':
			case 'info':
			case 'debug_conf':
			case 'config':
				$output = $help_mode;
				$end = true;
				break;
		};
	};
	return $output;
};

function debug__whitespace($input)
{
	$find = array(
		 "\n"
		,"\r"
		,"\t"
		,' '
	);
	$replace = array(
		 '\n'
		,'\r'
		,'\t'
		,'[[SPACE]]'
	);
	return str_replace($find,$replace,$input);
};

/**
 */
function debug__get_var_name( $var_value , &$var_name , $current_globals  )
{
	$tmp_name = '';
	foreach($current_globals as $globals_var_name => $globals_var_value)
	{
		if ($globals_var_value === $var_value)
		{
			$tmp_name = '$'.$globals_var_name;
		}
		elseif( is_array($globals_var_value) && $globals_var_name != 'GLOBALS' )
		{
			debug__get_var_name_from_array( $tmp_name , $var_value , $globals_var_name , $globals_var_value );
		};
		if( $tmp_name !== '' && debug__no_vname_already($tmp_name,$var_name) === true )
		{
			++$var_name['count'];
			if($var_name['count'] > 1)
			{
				$var_name['extra'] .= $var_name['space'].$tmp_name;
				$var_name['space'] = ' or ';
			}
			else
			{
				$var_name['name'] = $tmp_name.' ';
			};
		}
	};
};

/**
 * debug__get_var_name_from_array() attempts to match a the supplied
 * var value to a value within an array from the globals array.
 *
 * @param $_name string temporary variable name
 * @param $var_value mixed supplied variable value to be matched against
 * @param $g_name string name of global variable to be matched against
 * @param $g_value mixed value of global variable to be matched against
 */
function debug__get_var_name_from_array( &$t_name , $var_value , $g_name , $g_value )
{
	foreach( $g_value as $t_key => $t_value )
	{
		if( $t_key != 'GLOBALS' )
		{
			$t1_name = $g_name.'['.$t_key.']';
		}
		else
		{
			$t1_name = $t_key;
		};
		if( $var_value === $t_value && substr_compare( $t_key , 'DEBUG__' , 0 , 7))
		{
			if( $t_name == '' )
			{
				$t_name = $t1_name;
			}
			else
			{
				return;
			};
		}
		elseif( is_array($t_value) && $t_key != 'GLOBALS' )
		{
			debug__get_var_name_from_array( $t_name , $var_value , $t1_name , $t_value );
			if( $t_name != '' )
			{
				return;
			};
		};
	};
};
/**
 * debug__get_const_name() Checks to see if a given value matches
 * exactly the value of a defined constant.
 */
function debug__get_const_name( &$var_value , &$var_name , $current_const , $user_const = false )
{
	$all_const = false;
	if(is_string($var_value))
	{
		switch($var_value)
		{
			case 'help':
			case '?':
			case 'backtrace':
			case 'server':
			case 'request':
			case 'get':
			case 'post':
			case 'env':
			case 'files':
			case 'session':
			case 'cookie':
			case 'global':
			case 'globals':
			case 'forcedie':
			case 'force die':
			case 'force_die':
			case 'force-die':
			case 'config':
				return;
				break;
			default:
				if(preg_match('/^max[- _]times ?(?:= ?)?([0-9]*)$/' , $var_value))
				{
					return;
				};
				break;
		};
	}
	elseif(!is_bool($var_value) && !is_numeric($var_value))
	{
		return;
	};

	if($var_name['name'] != '' && $var_name['extra'] != '' )
	{
		$var_name_space = ' or ';
	}
	else
	{
		$var_name_space = '';
	};
	if($user_const === true )
	{
		$var_name = 'Sript defined CONSTANTS = ';
		$var_value = $current_const;
		return;
	}
	else
	{
		foreach($current_const as $key => $value)
		{
			if ($value === $var_value)
			{
				if($var_name['name'] == '' )
				{
					$var_name['name'] = '"'.$key.'" ';
				}
				else
				{
					$var_name['extra'] .= $var_name_space.'"'.$key.'" ';
					$var_name_space = ' or ';
				};
			};
		};
	};
	return;
};


function debug__no_vname_already($tmp_name , $var_name)
{
	$v_name = $var_name['name'].$var_name['extra'];
	$output = substr_count( $v_name , $tmp_name );
	if( $output == 0 )
	{
		return true;
	}
	else
	{
		return false;
	}
}

function debug__compact_names( $type = 'vars' )
{
	if( $type != 'vars' )
	{
		$type = 'CONST';
		$input = get_defined_constants();
	}
	else
	{
		$type = 'VARS';
		$input = $GLOBALS;
	};
	$tmp = '';
	$tmp_sp = '';
	foreach($input as $key => $var )
	{
		$tmp .= $tmp_sp.$key;
		$tmp_sp = ',';
	};
	define( 'DEBUG__PRE_DEFINED_'.$type , $tmp );
};

function debug__script_vars_only()
{
	$output = array();
	$pre_defined = debug__extract_names('vars');
	foreach( $GLOBALS as $key => $value )
	{
		if( !isset($pre_defined[$key]) || ( strlen($key) > 7 && substr_compare( $key , 'debug__' , 0 , 7 , true ) == 0 ))
		{
			$output[$key] = $value;
		};
	};
	return $output;
}


function debug__script_const_only()
{
	$output = get_defined_constants();
	$pre_defined = debug__extract_names('const');
	foreach( $pre_defined as $key => $value )
	{
		if( isset($output[$key]) || ( strlen($key) > 7 && substr_compare( $key , 'debug__' , 0 , 7 , true ) == 0 ))
		{
			unset($output[$key]);
		};
	};
	return $output;
}


function debug__extract_names( $type = 'vars' )
{
	$output = array();
	if($type != 'vars')
	{
		$tmp = explode(',' , DEBUG__PRE_DEFINED_CONST );
	}
	else
	{
		$tmp = explode(',' , DEBUG__PRE_DEFINED_VARS );
	};

	for( $a = 0 ; $a < count($tmp) ; ++$a )
	{
		$b = $tmp[$a];
		$output[$b] = '';
	}
	return $output;
}



// ==================================================================
// The following is for debugging the above functions.

/**
 * debug_debug() is used for debugging other functions in debug.inc.php
 * echos formatted debug info.
 *
 * @param $msg mixed (usually string)
 * @param $arr array
 */
function debug_debug($msg='',$arr=array())
{
	error_reporting( E_ALL | E_STRICT );
	$output = '';
	$included = debug_backtrace();
	$debug_line = $included[0]['line'];
	$debug_file = $included[0]['file'];
	unset($included);
	if(is_array($msg))
	{
		$arr=$msg;
		$msg='';
	};
	if(!empty($arr))
	{
		$arr='[[line]]'.debug__special_chars(print_r($arr,true));
	}
	else
	{
		$arr='';
	};
	if(defined('DEBUG__FORMAT') && DEBUG__FORMAT == 'text' )
	{
		echo "\n-----------------------------------------------------------\n(DEBUG_DEBUG() line $debug_line)\n".str_ireplace('[[line]]',"\n",$msg.$arr)."\n";
	}
	else
	{
		echo '<pre><strong>(line '.$debug_line.')</strong> '.str_ireplace('[[line]]',"\n",$msg.$arr).'</pre>';
	};
};

// ==================================================================
// The following is for debugging the above functions.

/**
 * debug_log() is used for debugging other functions in debug.inc.php
 * echos formatted debug info.
 *
 * @param $msg mixed (usually string)
 * @param $arr array
 */
function debug_log($msg='',$arr=array())
{
	error_reporting( E_ALL | E_STRICT );
	$output = '';
	$included = debug_backtrace();
	$debug_line = $included[0]['line'];
	$debug_file = $included[0]['file'];
	unset($included);
	if(is_array($msg))
	{
		$arr=$msg;
		$msg='';
	};
	if(!empty($arr))
	{
		$arr='[[line]]'.debug__special_chars(print_r($arr,true));
	}
	else
	{
		$arr='';
	};
	file_put_contents(DEBUG__LOG_FILE,"\n-----------------------------------------------------------\n(DEBUG_DEBUG() line $debug_line)\n".str_ireplace('[[line]]',"\n",$msg.$arr)."\n",FILE_APPEND);
};

function debug_parent($input)
{
	$parent = debug_backtrace();debug($parent);
	if(isset($parent[2]))
	{
		$debug_line = $parent[1]['line'];
		$debug_file = $parent[1]['file'];
		debug__wrap_text( $input , $debug_line , $debug_file );
		return;
	}
}

debug_conf();

else:
	debug('debug() has been defined elsewhere see debug_backtrace() output',debug_backtrace());

endif;
